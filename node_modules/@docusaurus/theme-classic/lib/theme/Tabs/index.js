"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _useUserPreferencesContext = _interopRequireDefault(require("@theme/hooks/useUserPreferencesContext"));

var _clsx = _interopRequireDefault(require("clsx"));

var _stylesModule = _interopRequireDefault(require("./styles.module.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const keys = {
  left: 37,
  right: 39
};

function Tabs(props) {
  const {
    lazy,
    block,
    defaultValue,
    values,
    groupId,
    className
  } = props;
  const {
    tabGroupChoices,
    setTabGroupChoices
  } = (0, _useUserPreferencesContext.default)();
  const [selectedValue, setSelectedValue] = (0, _react.useState)(defaultValue);

  const children = _react.Children.toArray(props.children);

  if (groupId != null) {
    const relevantTabGroupChoice = tabGroupChoices[groupId];

    if (relevantTabGroupChoice != null && relevantTabGroupChoice !== selectedValue && values.some(value => value.value === relevantTabGroupChoice)) {
      setSelectedValue(relevantTabGroupChoice);
    }
  }

  const changeSelectedValue = newValue => {
    setSelectedValue(newValue);

    if (groupId != null) {
      setTabGroupChoices(groupId, newValue);
    }
  };

  const tabRefs = [];

  const focusNextTab = (tabs, target) => {
    const next = tabs.indexOf(target) + 1;

    if (!tabs[next]) {
      tabs[0].focus();
    } else {
      tabs[next].focus();
    }
  };

  const focusPreviousTab = (tabs, target) => {
    const prev = tabs.indexOf(target) - 1;

    if (!tabs[prev]) {
      tabs[tabs.length - 1].focus();
    } else {
      tabs[prev].focus();
    }
  };

  const handleKeydown = (tabs, target, event) => {
    switch (event.keyCode) {
      case keys.right:
        focusNextTab(tabs, target);
        break;

      case keys.left:
        focusPreviousTab(tabs, target);
        break;

      default:
        break;
    }
  };

  return <div>
      <ul role="tablist" aria-orientation="horizontal" className={(0, _clsx.default)('tabs', {
      'tabs--block': block
    }, className)}>
        {values.map(({
        value,
        label
      }) => <li role="tab" tabIndex={0} aria-selected={selectedValue === value} className={(0, _clsx.default)('tabs__item', _stylesModule.default.tabItem, {
        'tabs__item--active': selectedValue === value
      })} key={value} ref={tabControl => tabRefs.push(tabControl)} onKeyDown={event => {
        handleKeydown(tabRefs, event.target, event);
      }} onFocus={() => changeSelectedValue(value)} onClick={() => {
        changeSelectedValue(value);
      }}>
            {label}
          </li>)}
      </ul>

      {lazy ? (0, _react.cloneElement)(children.filter(tabItem => tabItem.props.value === selectedValue)[0], {
      className: 'margin-vert--md'
    }) : <div className="margin-vert--md">
          {children.map((tabItem, i) => (0, _react.cloneElement)(tabItem, {
        key: i,
        hidden: tabItem.props.value !== selectedValue
      }))}
        </div>}
    </div>;
}

var _default = Tabs;
exports.default = _default;